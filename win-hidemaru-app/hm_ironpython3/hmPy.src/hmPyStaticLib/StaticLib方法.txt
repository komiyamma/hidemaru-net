内容は特に解説しませんが、C++/CLIのリンカのオプションで、CSC(C#のコンパイラ)の/target:module オプションを付けることで生成される .netmodule というファイルを渡せば双方がリンクできる、ということが書いてあります。

こいつらにできることがVisualStudio(MSBuild)にできないはずがない。

というわけで、さっそく私がたどりついたその方法を解説していきます。こうすればもっと簡単だよね〜という情報があったら是非ほしいところ。

スタートは、前回のラストの状態です。__declspec(dllexport)がついた関数を定義しているC++/CLIのプロジェクトが一つと、そのプロジェクトによって参照設定されているC#のクラスライブラリプロジェクトが一つある状態。


1. C++/CLIのプロジェクトからC#のプロジェクトへの参照設定を解除する。これによって、当然C++/CLI側のプロジェクトはコンパイルエラー（クラスが見つからない！）になる。

2. この操作によって見えなくなったクラスの定義を、C++/CLIで頑張ってヘッダファイルに書く。宣言部だけでOK。実装は不要。この作業はめんどくさいので、あらかじめC++/CLIから必要になるC#の定義は、できるだけシンプルにしておく。つまり、C++/CLIがexportしているAPIをまとめた小さなクラスかインターフェースにしておけ。この定義を変更するとC#とC++/CLIの双方に変更が必要になるので、インターフェースのほうがいいかも。インターフェースにする場合は、gcnewができないので別途ファクトリメソッドが必要になりますが、その辺はまぁ各自工夫していただくということで。

3. このヘッダファイルを必要に応じてincludeすれば、少なくともコンパイルは通る。でもリンクが通らない。実装がないから。この実装を、C#から持ってくる必要がある。

4. おもむろにC#のプロジェクトファイル(csproj)をテキストエディタで開いて、OutputType を Library から　Module に書き換える。ついでに、PlatformTarget が X86 になっている場合は AnyCPU に戻しておく。

5. この状態でC#のプロジェクトをビルドすると、.DLLの代わりに .netmodule というファイルが出力される。この中に、さっきC++/CLIで頑張って宣言を書いたクラスの実装が入っているはずだが、確認する術を私は持たない。

6. C++/CLIのプロジェクトに戻って、リンカオプションの「入力」、「追加の依存ファイル」のところに、先ほど生成した.netmoduleのパスを設定してからビルドすると・・・定義が間違っていない限り、リンクも通る！！.netmoduleってのはようは静的リンクライブラリなので、実行時には不要！！！ちなみに、2.で書いたクラスの定義が間違っていると、メタデータが一致しないとか言って怒られます。4.でAnyCPUになっていないと、LINK1302エラーが出ます。
